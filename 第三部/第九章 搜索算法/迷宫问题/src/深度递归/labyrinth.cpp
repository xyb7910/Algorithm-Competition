//迷宫问题－深度优先递归算法 
#include <iostream>
using namespace std;

const int m=6,n=8;//迷宫是6行8列

//二维数组的4行分别代表东南西北4个方向,而其中的2列分别表示前进的行位移量和列位移量,例如move[0][0]和move[0][1]表示向东前进,行位移量不变,列位移量加1
int move[4][2]={ {0,1},{1,0},{0,-1},{-1,0} };

//初始化迷宫每个位置为0,表示未被访问过,至于为什么加2,那是因为在迷宫的四周加墙,更方便问题的求解,其实迷宫只有m行n列
int visit[m+2][n+2]={
{0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0}
};

//迷宫的布置,1代表是墙,走不通,0表示可以通行
int maze[m+2][n+2]=
{
{1,1,1,1,1,1,1,1,1,1},
{1,0,0,1,1,0,1,0,1,1},
{1,1,0,0,1,1,0,0,0,1},
{1,0,0,0,0,0,0,1,1,1},
{1,1,1,0,1,1,0,0,0,1},
{1,0,0,0,0,0,1,0,1,1},
{1,1,0,1,0,0,0,0,0,1},
{1,1,1,1,1,1,1,1,1,1}
};

bool SeekPath(int x,int y)
{
  int i,g,h;//i作为循环变量,代表从当前位置移到下一个位置的方向，g和h作为下一个位置的行坐标和列坐标
  visit[1][1]=1;

  //从迷宫中坐标点(x,y)的位置寻找通向终点(m,n)的路径，若找到返回true，否则返回false.
  if (x==m && y==n)//到达出口返回true结束
   return true;
  for (i=0;i<4;i++)//求出下一个位置的行坐标和列坐标
  {
     g=x+move[i][0];
     h=y+move[i][1];
     if((maze[g][h]==0) && (visit[g][h]==0))//若下一位置可以通行并且没有被访问过，则从该位置起寻找
     {
        visit[g][h]=1;//置mark数组中对应的位置为1，表明已经访问过
        if(SeekPath(g,h))
        {
          cout<<g<<' '<<h<<endl;
          return true;
        }
     }
  }
  return false;
}

int main()
{
  if(SeekPath(1,1))
   cout<<1<<' '<<1<<endl;
   getchar();
  return 0;
}
